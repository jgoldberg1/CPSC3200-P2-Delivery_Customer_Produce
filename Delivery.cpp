/*
 *  Implementation Invariant
 * Delivery()
 * - default constructor that initializes to invalid state
 * Delivery(int minPrice)
 * makeProduce(int minPrice, int currTime)
 * - randomly generates and returns a produce object. uses helper functions to generate attributes.
 *  - has a minPrice that defaults to 0 so it can be used in the initial scheduling of a delivery, where there is no
 *  minimum price, and in the replace() function, where the produce generated must have a minimum price to maintain
 *  the order's overall minimum price.
 *  - has a currTime that defaults to 0 so it can be used in the initial scheduling of a delivery, where there is no
 *  minimum expiration date, and in the replace() function, where the produce generated must have an expiration date
 *  after the current time.
 * expand(Produce* arr)
 * - doubles the size of the array. allocates new memory that is double the old memory, then copies over the contents
 *   of the old array, then deletes the old array.
 * forecastDelivery()
 * - Incrementally generates and adds Produce objects to an array representing the order, until the Customer's minPrice
 *   is reached. the array is newProduce, NOT the attribute deliveryItems. This is because of the wording of the
 *   instructions, which imply that forecastDelivery should not populate deliveryItems, but should generate a list of
 *   specific Produce objects to use in the delivery. Hence the objects are generated here, but not moved to their final
 *   spot.
 * fillBox()
 * - allocates memory pointed to by deliveryItems, and copies over the produce items from newProduce to deliveryItems,
 *   using move semantics. newProduce was previously generated by forecastDelivery().
 * replaceItem(int itemIndex)
 * - calls the generation of a new Produce item in deliveryItems at itemIndex. The new item generated has a cost equal
 *   or greater than the original item at itemIndex.
 * - adjusts the value of _totalPrice according to the cost of the new Produce item.
 * genNameIndex()
 * - helper func, generates index for NAMES array to be used in makeProduce()
 * genClassIndex()
 * - helper func, generates index for CLASSIFICATIONS array to be used in makeProduce()
 * genStorageIndex()
 * - helper func, generates index for STORAGE_REQS array to be used in makeProduce()
 * genCost()
 * - helper func, generates int cost to be used in makeProduce()
 * genAmount()
 * - helper func, generates int amount to be used in makeProduce()
 * genMaxMaxTime()
 * - helper func, generates int maxTime to be used in makeProduce()
 *
 *
 *
 *
 */
#include <iostream>
#include <cstdlib>
#include <random>
#include "Delivery.h"
#include "Produce.h"

random_device rdDelivery;
mt19937 mtDelivery(rdDelivery());
uniform_int_distribution<int> distroDelivery(0, RAND_MAX);
uniform_real_distribution<double> distroDoubleDelivery(0, RAND_MAX);


Delivery::Delivery()
{
    _numItems = -1;
    _maxSize = -1;
}


//Constructor
Delivery::Delivery(int minPrice)
{
    Produce* newProduce = forecastDelivery(minPrice);
    fillBox(newProduce);
}

//Preconditions: src, the address of a delivery object
//Postconditions: contents of src are copied to the object
void Delivery::copy(const Delivery& src)
{
    _numItems = src._numItems;
    _maxSize = src._maxSize;
    _totalCost = src._totalCost;
    deliveryItems = new Produce[_numItems];
    for (int i = 0; i < _numItems; i++)
    {
        deliveryItems[i] = src.deliveryItems[i];
    }

}

//Copy Constructor
Delivery::Delivery(const Delivery& src)
{
    copy(src);
}

//Copy assignment operator
Delivery& Delivery::operator=(Delivery& src)
        {
            if (this == &src) return *this;
            copy(src);
            return *this;
        }

//Move constructor
Delivery::Delivery(Delivery&& src) noexcept
{
    copy(src);
    src._numItems = 0;
    src._maxSize = 0;
    src._totalCost = 0;
    delete[] src.deliveryItems;
    src.deliveryItems = nullptr;
}

//Move assignment operator
Delivery& Delivery::operator=(Delivery&& src) noexcept
        {
    if (this == &src) return *this;
    copy(src);
    src._numItems = 0;
    src._maxSize = 0;
    src._totalCost = 0;
    delete[] src.deliveryItems;
    src.deliveryItems = nullptr;
    return *this;
}

//Precondition: None
//Postcondition: returns the total cost. getter function
double Delivery::getTotalCost() const { return _totalCost; }

//Precondition: maxIndex, the maximum number possible to generate
//Postcondition: returns int between 0 and maxIndex
int Delivery::genNameIndex(int maxIndex)
{
    return (distroDelivery(mtDelivery) % maxIndex);
}

//Precondition: maxIndex, the maximum number possible to generate
//Postcondition: returns int between 0 and maxIndex
int Delivery::genClassIndex(int maxIndex)
{
    return (distroDelivery(mtDelivery) % maxIndex);
}

//Precondition: maxIndex, the maximum number possible to generate
//Postcondition: returns int between 0 and maxIndex
int Delivery::genStorageMethodIndex(int maxIndex)
{
    return (distroDelivery(mtDelivery) % maxIndex);
}

//Precondition: minCost and maxCost, the min and max values possible to generate
//Postcondition: returns double between minCost and maxCost
double Delivery::genCost(double minCost, double maxCost)
{
    return (fmod(distroDoubleDelivery(mtDelivery), maxCost) + minCost);
}

//Precondition: maxAmount, the max value possible to generate
//Postcondition: returns int between 0 and maxAmount
int Delivery::genAmount(int maxAmount)
{
    return (distroDelivery(mtDelivery) % maxAmount);
}

//Precondition: maxMaxTime, the max value possible to generate
//Postcondition: returns int between 0 and maxMaxTime
int Delivery::genMaxTime(int currTime, int maxMaxTime)
{
    return (distroDelivery(mtDelivery) % maxMaxTime + currTime);
}

Delivery::~Delivery()
{
    delete[] deliveryItems;
}


//Precondition: minCost, the minimum cost of the generated produce object
//Postcondition: returns Produce object with randomly generated attributes
Produce Delivery::makeProduce(double minCost = 0.0, int currTime = 0) {
    double MAX_COST = 100.00;
    int MAX_AMOUNT = 100;
    int MAX_TIME = 500;
    const string NAMES[] = {"Potato", "Onion", "Winter Squash", "Garlic", "Apple", "Cilantro",
                      "Blueberry", "Zucchini", "Apricot", "Chantrelle Mushrooms", "Banana",
                      "Thyme", "Oyster Mushroom"};
    const string CLASSIFICATIONS[] = {"Fruit", "Vegetable", "Fungus", "Herb"};
    const string STORAGE_REQS[] = {"dark", "counter", "refrigerate"};
    int namesIndex = genNameIndex(int(*(&NAMES+1)-NAMES-1));
    int classIndex = genClassIndex(int(*(&CLASSIFICATIONS+1)-CLASSIFICATIONS-1));
    int storageReqsIndex = genStorageMethodIndex(int(*(&STORAGE_REQS+1)-STORAGE_REQS-1));
    int storageMethIndex = genStorageMethodIndex(int(*(&STORAGE_REQS+1)-STORAGE_REQS-1));
    double cost = genCost(minCost, MAX_COST);
    double amount = genAmount(MAX_AMOUNT);
    int maxTime = genMaxTime(currTime, MAX_TIME);
    ProduceInput pInfo = {
            NAMES[namesIndex],
            CLASSIFICATIONS[classIndex],
            cost,
            amount,
            STORAGE_REQS[storageReqsIndex],
            STORAGE_REQS[storageMethIndex],
            maxTime
    };
    Produce p = Produce(pInfo);
    return p;
}

//Precondition: pointer to an array of produce objects
//Postcondition: pointer to an array of produce objects
Produce* Delivery::expand(Produce *arr)
{
    _maxSize *= 2;
    Produce* newArr = new Produce[_maxSize];

    for (int i = 0; i < _numItems; i++)
    {
        newArr[i] = arr[i];
    }
    delete[] arr;
    arr = newArr;
    newArr = nullptr;
    return arr;
}

//Precondition: minPrice, the minimum total price the order should have
//Postcondition: returns an array of produce objects
Produce* Delivery::forecastDelivery(int minPrice)
{
    _totalCost = 0;
    Produce* newProduce = new Produce[_maxSize];
    while (_totalCost < minPrice) {
        if (_numItems >= _maxSize) newProduce = expand(newProduce);
        newProduce[_numItems] = makeProduce();
        _totalCost += newProduce[_numItems].getCost();
        _numItems++;
    }
    return newProduce;
}

//Precondition: newProduce, an array of produce objects
//Postcondition: None
void Delivery::fillBox(Produce* newProduce)
{
    deliveryItems = new Produce[_numItems];
    for (int i = 0; i < _numItems; i++)
    {
        deliveryItems[i] = newProduce[i];
    }
}

//Precondition: itemIndex, the deliveryItems index of the item to be replaced
//Postcondition: None
void Delivery::replaceItem(int itemIndex, int currTime)
{
    double minCost = deliveryItems[itemIndex].getCost();
    _totalCost -= minCost;
    deliveryItems[itemIndex] = makeProduce(minCost, currTime);
    _totalCost += deliveryItems[itemIndex].getCost();
}



//Precondition: currTime, the time at which the box is to be delivered
//Postcondition: items that are expired at the time of currTime are replaced by nonspoiled items.
void Delivery::deliverBox(int currTime)
{
    for (int i = 0; i < _numItems; i++)
    {
        if(deliveryItems[i].checkExpired(currTime))
        {
            replaceItem(i, currTime);
        }
    }
}

//Precondition: None
//Postcondition: returns a string with information about all the produce items in the Delivery
string Delivery::shareOrder()
{
    string report;
    for (int i = 0; i < _numItems; i++)
    {
        report += deliveryItems[i].query();
    }
    return report;
}





