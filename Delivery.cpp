//
// Created by jenma on 1/15/2022.
//
/*
 * Class Invariant (description of class)
 * The purpose of this class is to model deliveries put together by a produce delivery service. Deliveries have a
 * variable number of Produce items in the array deliveryList. Once Delivery objects are initialized, the client can
 * call deliverBox(currTime) to "deliver" the box, at which point any produce that expired before the delivery time
 * currTime will be replaced with nonspoiled produce. In addition, the class can query information about the delivery
 * or the cost of the delivery.
 *
 * Interface Invariant (explanation of public methods)
 * Delivery()
 * -  default constructor that is not meant to be used. If it is used, the class will not work properly
 * Delivery(int minPrice)
 * - parameterized constructor meant to be used. Initializes the object and adds the generated Produce to it
 * getTotalCost()
 * - getter function for _totalCost
 * shareOrder()
 * - returns a string with information about all the produce items in the Delivery
 * deliverBox(int currTime)
 * - checks if each item in deliveryList will be expired at the time of delivery (currTime). If they are/will be
 *   expired, they are replaced.
 *
 */

/*PUT AT BOTTOM OF DOC
 *  Implementation Invariant (explanation of design choices)
 * Delivery()
 * - default constructor that initializes to invalid state
 * Delivery(minPrice)
 * -
 * makeProduce(minPrice, currTime)
 * - randomly generates and returns a produce object. uses helper functions to generate attributes.
 *  - has a minPrice that defaults to 0 so it can be used in the initial scheduling of a delivery, where there is no
 *  minimum price, and in the replace() function, where the produce generated must have a minimum price to maintain
 *  the order's overall minimum price.
 *  - has a currTime that defaults to 0 so it can be used in the initial scheduling of a delivery, where there is no
 *  minimum expiration date, and in the replace() function, where the produce generated must have an expiration date
 *  after the current time.
 * expand(Produce* arr)
 * - doubles the size of the array. allocates new memory that is double the old memory, then copies over the contents
 *   of the old array, then deletes the old array.
 * forecastDelivery()
 * - Incrementally generates and adds Produce objects to an array representing the order, until the Customer's minPrice
 *   is reached. the array is newProduce, NOT the attribute deliveryItems. This is because of the wording of the
 *   instructions, which imply that forecastDelivery should not populate deliveryItems, but should generate a list of
 *   specific Produce objects to use in the delivery. Hence the objects are generated here, but not moved to their final
 *   spot.
 * fillBox()
 * - allocates memory pointed to by deliveryItems, and copies over the produce items from newProduce to deliveryItems,
 *   using move semantics. newProduce was previously generated by forecastDelivery().
 * replaceItem(int itemIndex)
 * - calls the generation of a new Produce item in deliveryItems at itemIndex. The new item generated has a cost equal
 *   or greater than the original item at itemIndex.
 * - adjusts the value of _totalPrice according to the cost of the new Produce item.
 *
 *
 *
 *
 *
 */
#include <iostream>
#include <cstdlib>
#include <random>
#include "Delivery.h"
#include "Produce.h"

random_device rdDelivery;
mt19937 mtDelivery(rdDelivery());
uniform_int_distribution<int> distroDelivery(0, RAND_MAX);
uniform_real_distribution<double> distroDoubleDelivery(0, RAND_MAX);


Delivery::Delivery()
{
    _numItems = -1;
    _maxSize = -1;
}


//Constructor
Delivery::Delivery(int minPrice)
{
    Produce* newProduce = forecastDelivery(minPrice);
    fillBox(newProduce);
}

//Preconditions: src, the address of a delivery object
//Postconditions: contents of src are copied to the object
void Delivery::copy(const Delivery& src)
{
    _numItems = src._numItems;
    _maxSize = src._maxSize;
    _totalCost = src._totalCost;
    deliveryItems = new Produce[_numItems];
    for (int i = 0; i < _numItems; i++)
    {
        deliveryItems[i] = src.deliveryItems[i];
    }

}

//Copy Constructor
Delivery::Delivery(const Delivery& src)
{
    copy(src);
}

//Copy assignment operator
Delivery& Delivery::operator=(Delivery& src)
        {
            if (this == &src) return *this;
            copy(src);
            return *this;
        }

//Move constructor
Delivery::Delivery(Delivery&& src) noexcept
{
    copy(src);
    src._numItems = 0;
    src._maxSize = 0;
    src._totalCost = 0;
    delete[] src.deliveryItems;
    src.deliveryItems = nullptr;
}

//Move assignment operator
Delivery& Delivery::operator=(Delivery&& src) noexcept
        {
    if (this == &src) return *this;
    copy(src);
    src._numItems = 0;
    src._maxSize = 0;
    src._totalCost = 0;
    delete[] src.deliveryItems;
    src.deliveryItems = nullptr;
    return *this;
}

//Precondition: None
//Postcondition: returns the total cost. getter function
int Delivery::getTotalCost() const { return _totalCost; }

//Precondition: maxIndex, the maximum number possible to generate
//Postcondition: returns int between 0 and maxIndex
int Delivery::genNameIndex(int maxIndex)
{
    return (distroDelivery(mtDelivery) % maxIndex);
}

//Precondition: maxIndex, the maximum number possible to generate
//Postcondition: returns int between 0 and maxIndex
int Delivery::genClassIndex(int maxIndex)
{
    return (distroDelivery(mtDelivery) % maxIndex);
}

//Precondition: maxIndex, the maximum number possible to generate
//Postcondition: returns int between 0 and maxIndex
int Delivery::genStorageMethodIndex(int maxIndex)
{
    return (distroDelivery(mtDelivery) % maxIndex);
}

//Precondition: minCost and maxCost, the min and max values possible to generate
//Postcondition: returns double between minCost and maxCost
double Delivery::genCost(double minCost, double maxCost)
{
    return (fmod(distroDoubleDelivery(mtDelivery), maxCost) + minCost);
}

//Precondition: maxAmount, the max value possible to generate
//Postcondition: returns int between 0 and maxAmount
int Delivery::genAmount(int maxAmount)
{
    //uniform_int_distribution<int> distro(0, maxAmount);
    return (distroDelivery(mtDelivery) % maxAmount);
}

//Precondition: maxMaxTime, the max value possible to generate
//Postcondition: returns int between 0 and maxMaxTime
int Delivery::genMaxTime(int currTime, int maxMaxTime)
{
    //uniform_real_distribution<float> distro(0, maxMaxTime);
    return (distroDelivery(mtDelivery) % maxMaxTime + currTime);
}

Delivery::~Delivery()
{
    delete[] deliveryItems;
    //cout << "Destruction success" << endl;
}


//Precondition: minCost, the minimum cost of the generated produce object
//Postcondition: returns Produce object with randomly generated attributes
Produce Delivery::makeProduce(double minCost = 0.0, int currTime = 0) {
    //cout << "in makeProduce" << endl;
    double MAX_COST = 100.00;
    int MAX_AMOUNT = 100;
    int MAX_TIME = 500;
    string names[] = {"Potato", "Onion", "Winter Squash", "Garlic", "Apple", "Cilantro",
                      "Blueberry", "Zucchini", "Apricot", "Chantrelle Mushrooms", "Banana",
                      "Thyme", "Oyster Mushroom"};
    string classifications[] = {"Fruit", "Vegetable", "Fungus", "Herb"};
    string storageReqs[] = {"dark", "counter", "refrigerate"};
    //cout << (*(&names+1)-names) << endl;
    int namesIndex = genNameIndex(int(*(&names+1)-names-1));
    int classIndex = genClassIndex(int(*(&classifications+1)-classifications-1));
    int storageReqsIndex = genStorageMethodIndex(int(*(&storageReqs+1)-storageReqs-1));
    double cost = genCost(minCost, MAX_COST);
    double amount = genAmount(MAX_AMOUNT);
    int maxTime = genMaxTime(currTime, MAX_TIME);
    //cout << "just stuff. food: " << namesIndex << " storageMethod: " << storageReqsIndex << " expirationDate:" << maxTime << endl;
    Produce p = Produce(names[namesIndex], classifications[classIndex], cost, amount,
                           storageReqs[storageReqsIndex], maxTime);
    //cout << "op= successful" << endl;
    return p;
}

//Precondition: pointer to an array of produce objects
//Postcondition: pointer to an array of produce objects
Produce* Delivery::expand(Produce *arr)
{
    //cout << "in expand" << endl;
    _maxSize *= 2;
    Produce* newArr = new Produce[_maxSize];

    for (int i = 0; i < _numItems; i++)
    {
        newArr[i] = arr[i];
    }
    delete[] arr;
    arr = newArr;
    newArr = nullptr;
    return arr;
    cout << "expansion complete" << endl;
}

//Precondition: minPrice, the minimum total price the order should have
//Postcondition: returns an array of produce objects
Produce* Delivery::forecastDelivery(int minPrice)
{
    //cout << "in forecast delivery" << endl;
    _totalCost = 0;
    Produce* newProduce = new Produce[_maxSize];
    while (_totalCost < minPrice) {
        if (_numItems >= _maxSize) newProduce = expand(newProduce);
        //cout << "num items: " << _numItems << " maxSize: " << _maxSize << endl;
        newProduce[_numItems] = makeProduce();
        //cout << "out of makeProduce" << endl;
        _totalCost += newProduce[_numItems].getCost();
        _numItems++;
    }

    //cout << "forecastDelivery complete" << endl;
    cout << "totalCost in forecastDelivery: " << _totalCost << endl;
    return newProduce;
}

//Precondition: newProduce, an array of produce objects
//Postcondition: None
void Delivery::fillBox(Produce* newProduce)
{
    //cout << "in fillBox" << endl;
    deliveryItems = new Produce[_numItems];
    for (int i = 0; i < _numItems; i++)
    {
        //cout << "in fillBox loop" << endl;
        deliveryItems[i] = newProduce[i];
    }
}

//Precondition: itemIndex, the deliveryItems index of the item to be replaced
//Postcondition: None
void Delivery::replaceItem(int itemIndex, int currTime)
{
    //cout << "in replaceItem" << endl;
    double minCost = deliveryItems[itemIndex].getCost();
    _totalCost -= minCost;
    deliveryItems[itemIndex] = makeProduce(minCost, currTime);
    _totalCost += deliveryItems[itemIndex].getCost();
}



//Precondition: currTime, the time at which the box is to be delivered
//Postcondition: items that are expired at the time of currTime are replaced by nonspoiled items.
void Delivery::deliverBox(int currTime)
{
    //cout << "in deliverBox" << endl;
    for (int i = 0; i < _numItems; i++)
    {
        if(deliveryItems[i].checkExpired(currTime))
        {
            replaceItem(i, currTime);
        }
    }
    //cout << "_totalCost in deliverbox " << _totalCost << endl;
}

//Precondition: None
//Postcondition: returns a string with information about all the produce items in the Delivery
string Delivery::shareOrder()
{
    //cout << "in shareOrder" << endl;
    string report;
    for (int i = 0; i < _numItems; i++)
    {
        report += deliveryItems[i].query();
    }
    return report;
}





